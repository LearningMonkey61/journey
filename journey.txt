 vim: tw=80 sw=2 ts=2 et
-----------
2018.01.02:
    
bash:
  indirect expansion ${!var}
    var=foo ; foo=hoo; echo ${!var}

  ${parameter#word}, remove matching prefix as less as possible
  ${parameter##word}, remove matching prefix as much as possible

  ${parameter%word}, remove matching tail as less as possible
  ${parameter%%word}, remove matching tail as much as possible

  here string 
    <<<str

-----------
2018.01.03:

bash:
  IFS sequence of characters used to split fields. default to <space><tab><newline>

  "$*" = "$1c$2c$3..."
  "$@" = "$1"c"$2"c"$3"...

  array:
    indexed array works like vector
    declare -a l ; l=(a b c d e) ; echo ${#l[@]} ;  unset l[0] ; echo ${l[@]}

    associatived array works like map
    declare -A m; m[a]=A ; m[b]=B ; m[c]=C ; unset m[b] ; echo ${#m[@]} ; echo ${!m[@]} ; echo ${m[@]}

-----------
2018.01.06:

vim:
  winnr('$') get number of windows
  bufwinnr(winbufnr(winid)) convert winid to winnr
  use getwinvar() to retrieve window variable and option
  use getwininfo() to retreive window infor

-----------
2018.01.07:

vim:
  You can not set break point at anomymous function(numbered funcition). You should use normal
  function with dict postfix.
  use :function /pattern to search function

-----------
2018.01.08:

wsl:
  wsl doesn't support gui related stuff.

bash:
  grep -L ...  get files without match
  you can nest "" if the inner "" is used to quote sub command result
  !!:0  repeat last command, discard everything except 1st word

ag:
  ag use pcre(3) with multiline enabled search pattern.

linebreak:
  unix    LF   0A   \n
  windows CRLF 0D0A \r\n
  mac     CR   0D   \r
  Make sure you don't mix fileformat, some search patterns rely on it.

vim:
  gp paste below cursor, place cursor at end of newly pasted context
  in order to search literal string with line break, use
     substitute(escape(string, '\/?'), "\n", '\\n', 'g')
  replace string musbe be '\\n', '\n' won't work. It works like manually type /Ctrl-r=string
  when searching, \n is newline, \r is CR (carriage return = Ctrl-M = ^M) 
  when replacing, \r is newline, \n is a null byte (0x00).

-----------
2018.01.09:

bash:
  grep -F and ag -F are totally different,  grep -F interpret pattern as a list
  of new line seperated strings, each string will be used as a search pattern,
  any of which is to be matched seperately.  ag -F match pattern as whole
  string, including "newline".
  You can not use \n as line break in literal search, you must use the real
  linebreak character(0X0A for unix)

-----------
2018.01.09:

vim:
  shellescape(str) escape str to be used for shell command arg,
  ' => '\''
  \n and ! will be escaped once or twice
  %#will be escaped zero or once

  If you want to use str as literial match, leave \n and ! alone, but escape %#
  and | (if your ex command has -bar option) if you will use it'll be used in a
  ex command.

-----------
2018.01.10:

sed:
  by default, sed output all the processed text, use -n to suppress it
  sed took script from --expression or --file or the first non option argument
  if there has no -e or -f. 
  you can specify multiple input to sed, they will be combined together as a single giant input, you
  can also use -s to tell sed to treat them seperately.
  Commands within a script or script-file can be separated by semicolons (;) or newlines (ASCII 10).
  Multiple scripts can be specified with -e or -f options.

  all sed command follow this syntax:
    [addr]X[options]

vim:
  special line number in range:
    /{pattern}[/]  [/] is needed to seperate pattern from anything that follows
    ?{pattern}[?]  
    \/             use previous search pattern
    \?
    \&             use previous substitute pattern
    /pat1//pat2/   find line contain "pat2" after line containing "pat1", without moving the cursor

  range can be seperated with , or ;
    5;/pat2/       find line contain "pat2" after line 5, pat2 search will start after line 5

-----------
2018.01.12:

sed:
  sed address is very much alike vim range, except:
    blank range indicate whole file
    post ! after range is used to negate the sense of match

  sed use BRE by default, -e will switch to ERE

regex:
  backreference: \# reference previous # capturing group, \1 matches the exact
  same text that was matched by the first capturing group. 

gl:
  always clear depth if you depth test is enabled.
  
-----------
2018.01.13:

gl:
  lighting of normalmap is prefered to be calculated in tangent space, which
  means you have to transform light, camera into tangent space in vertex shader.
  Local viewer of light model has no meaning in tangent space lighting.

  Although it's easier to calculate normalmap lighting in view space, you only
  need to transfrom normal from tbn space to view space in fragment shader.

-----------
2018.01.14:

gl:
  for debug purpose, it'd better to get used to normal colors:

  normal      | color         | basic color name 
  ------------|-----------------------------------
  1,  0,  0   | 1,   0.5, 0.5 | light brown?
  0,  1,  0   | 0.5, 1,   0.5 | light lime?
  0,  0,  1   | 0.5, 0.5, 1   | light blue ?
  -1, 0,  0   | 0,   0.5, 0.5 | teal
  0,  -1, 0   | 0.5, 0,   0.5 | purple
  0,  0,  -1  | 0.5, 0.5, 0   | olive

  basic rgb colors:
    Black   #000000 (0,0,0)
    White   #FFFFFF (255,255,255)
    Red     #FF0000 (255,0,0)
    Lime    #00FF00 (0,255,0)
    Blue    #0000FF (0,0,255)
    Yellow  #FFFF00 (255,255,0)
    Cyan    #00FFFF (0,255,255)
    Magenta #FF00FF (255,0,255)
    Silver  #C0C0C0 (192,192,192)
    Gray    #808080 (128,128,128)
    Maroon  #800000 (128,0,0)
    Olive   #808000 (128,128,0)
    Green   #008000 (0,128,0)
    Purple  #800080 (128,0,128)
    Teal    #008080 (0,128,128)
    Navy    #000080 (0,0,128)


  yellow = red + green
  cyan = green + blue
  magenta = red + blue

-----------
2018.01.15:

gl:
  If your vertex attribute array looks weird, such as the w componnet is not 1 or the number of
  components is not right, you might forgot to enable this attribute array.

sed:
  you can specify number flag to replace only nth match.

vim:
  bufexists works on full path name, tild path name, and relative path name
  There is no number flag in substitute, you can only do it with following regex:
  s/\v%((pattern).{-}){n-1th}\zspattern/replace pattern/

-----------
2018.01.16:

freeimage:
  FreeImage uses a BGR[A] pixel layout under a Little Endian processor (Windows, Linux) and uses a
  RGB[A] pixel layout under a Big Endian  processor (Mac OS X or any Big Endian Linux / Unix). 

-----------
2018.01.17:

lldb:
  Lldb 3.8 only support watchpoint for built in type?
  Faild to set watch point for glm::mat4[0][0], always complain failed to send
  gdb stuff.

vim:
  undo branches:
    normal undo(u) redo(ctrl-r) goes back and forward along current branch. When you undo something
    and make a change, vim will create a new undo branch for you.
    Every change you made is numbered, you can travel along it with g- and g+, or :earlier, :later,
    g- is the same as earlier 1, g+ is the same as g+. You can also goto specific change directly
    with :undo N (:undo N is totally different from :undo), if N is in current branch, current
    branch didn't change, otherwise, current branch is changed to branch that contains N (If
    multiple branches contain N, use the one with largest change number).
    :earlier {N}{[s|m|h|d]} works with time
    :earlier {N}f goto older text state {N} file writes before.
    :undolist will list head chagne of every branch.

  there is no way to paste literal linebreak directly, you must use = register
  to do this

-----------
2018.01.18:

vim:
  if command has -bar option, you must escape | if you want to use it as
  argument.
  ex command will expand % to current file, # to alternate file
  grep will use !shellcmd ? which means if you want to match literal linebrak,
  you must escape it.

  file search:
    downward search:
      ** matches only directory in file search, 
      **5 means maximum number of levels matched is 5

    upward search:
      usually used to search for a file
      /a/b/c/d;/a/b will search in:
        /a/b/c/d
        /a/b/c
        /a/b
      /a/b is called stop directory, it should be appended to previous path with
      a ';'. if you omit it, vim will search until root.
      e;/a/b  will search in (assume current dir is /a/b/c/d):
        /a/b/c/d/e
        /a/b/c/e
        /a/b/e

    combined search:
      **;/a/b wil search in(assume crrent dir is /a/b/c/d):
      /a/b/c/d/**
      /a/b/c/**
      /a/b/**

  'tags' : by default &tags = ./tags;,tags
    if cpoption doesn't include 'd' ./ will expand to path of current file.

  gl:
    it's totally legal to bind the same buffer to different target.

-----------
2018.01.18:

linux:
  check cpu :
    lscpu
    cat /proc/cpuinfo 
  check disk and partition :
    lsblk
    fdisk -l
  check disk filesystem:
    df -T
  check slot on mother board:
    lspci
  check cpu bit :
    getconf LONG_BIT 
  check memory :
    free
    cat /proc/meminfo  
  check memory hardware :
    dmidecode -t memory
  check bios :
    dmidecode -t bios
  check all DMI(desktop management interface) info
    dmidecode -q
  check system info :
    uname -a
  check usb:
    lsusb
  check hardware:
    lshw

  iconv can be used to change character encoding

vim:
  :set change both global and local option
  :setglobal set global option
  :setlocal set local option
  setlocal option< set local value to it's global value
  set option<  remove local value, so global value will be used

  fileencodings : 
    when you edit an existing file in vim, vim will try fileencoding in
    'fileencodings' in sequence, utf-8 will be used if all failed, fileencoding
    will be set to an empty string, so you should put special encoding (such as
    ucs-bom)in the front part, and common encoding(such as latin1) in the back.
    fileencodings is ignored if ++enc option exists
    if fileencodings is empty, vim will use global fileencoding

  fileencoding :
    when you edit a new file, global fileencoding will be used. If fileencoding
    is empty, utf-8 will be used.  if fileencoding is not utf-8, conversion will
    be done when writting the file(via internal iconv).
  
  encoding:
    vim internal encoding, it's always utf-8

  ga : print ascii value
  g8 : print hex value
  8g8 : find illegal utf-8 byte sequence

-----------
2018.01.20:

vim:
  ctrl-\_e replace whole cmdline with expressiion, you might need getcmdtype(),
  getcmdline(), getcmdpos(), setcmdpos() to help you with it.

  help topic:
    prefix   example    context
    :        :h let     excmd
    none     :h r       normal mode
    v_       :h v_*     visualmode
    i_       :h i_*     insert mode
    c_       :h c_*     ex command line
    /        :h /*      search patterno
    '        :h '*'     option
    -        :h -*      vim argument
   you can use ctrl-v to insert the special key want to search help for that key

-----------
2018.01.20:

vim:
  search-offset:
    /pattern/[bse][num]   apply lines or characters offset
    /pattern0/;/patten1/  use /patten1/ as offset, search start after match of pattern0

bash:
  nl   add line number to output

-----------
2018.01.23:

vim:
  You can get all special character code in :digraph, or search digraph-table

c++:
  when you insert something at iter to a vector, if the vector needs to be
  reallocated, all iterators will be invalidated, otherwise only iteraters
  starts from iter will be invalidated.

-----------
2018.01.25:

bash:
  xargs took as much augument as possible per command line, unless you specify -n
  if you want to use xargs with itmes contain space:   
    print item lines | xargs -d "\n" -n1 cmd

  \ in double quotes escapes only $, `, ", \, or newline, otherwise it's removed.

-----------
2018.01.26:

gl:
  billboard: there are mainly 3 kinds of billboard
    0 : align billboard rotatoin to camera rotation
    2 : rotate z to center_to_camera, don't care about orientation.
    3 : look at camera from billboard center, use camera up as up.

  You can also create billboard just like you render 2d text.

  You can also create billboard by transform billboard center to ndc (the depth
  value is generated in the same ways as other renderable in the scene), and
  then define your billboard directly in ndc(If you want to create billboard in
  fixed size, this is an option).

vim:
  vim use b:current_syntax to guard syntax file loading.
  If want to just add or change some syntax to current syntax file, place you
  syntax file under runtimepath/after/syntax/, and don't set b:currentsyntax

-----------
2018.01.27:

c++:
  if you erase iter of list while you are looping, only the erased iter got
  invalidated, which means ++iter will fail, you need to do it like this:
    auto it = iter;
    ++it;
    l.erase(iter)

-----------
2018.01.28:

ssh:
  there are mainly two ways to use ssh:
    1: username,password, commonly used on unix system.
    2: public key authorization(commonly used in android system):
      use ssh-genkey to generate private and public key
      keep private key to your self, copy public key to server .ssh/authorized_keys

android:
  you can install termux in your android to use it like linux.
  termux use 8022 as default port for ssh.

linux:
  check dir or file space usage : du -hs /etc
  You can use deja-dup to bakup, restore.
  You can restore a single file or directory : as deja-dup --restore

  You can use grep -A to print more lines after match.

-----------
2018.01.29:

linux:
  daemon:
    A daemon is a computer program that runs as a background process in
    multitasking computer operating system. Traditionally the process names of a
    daemon end with the letter d.
    Deamon is not attached to a tty, which means you can list deamon process as:
      ps -eo tty,pid,comm | grep ^?

    You can use initctrl to control init deamon. 
      initctrl list
      initctrl status ssh-agent

  orphan process: parent dead, but still executing, adopted by init(pid 1).

  zombie(defunct) process : a process that has completed execution (via the exit
    system call) but still has an entry in the process table: it is a process in
    the "Terminated state". This occurs for child processes, where the entry is
    still needed to allow the parent process to read its child's exit status:
    once the exit status is read via the wait system call, the zombie's entry is
    removed from the process table and it is said to be "reaped". A child
    process always first becomes a zombie before being removed from the resource
    table. In most cases, under normal system operation zombies are immediately
    waited on by their parent and then reaped by the system – processes that
    stay zombies for a long time are generally an error and cause a resource
    leak. The kill command has no effect on zombie process.

  An orphan zombie process will be reaped automatically.

  terminal = tty = text input/output enviroment
  console = pyshical terminal

  shell is the outer most layer around the operating system kernel.
  There are two kinds of shell:
    command line interface(CLI).
    graphical user interface(GUI).
    
  there are two kinds of tty:
    hardware tty : one end connected to hardware, one end connected to software
    pesudo tty : both ends connected to software.

-----------
2018.01.30:

vim:
  If there exists multiple entries of the same line in quickfix list, and you
  want to make change to every quickfix entry, you need to revert the quickfix
  list first, otherwise only entry of the same line will will be changed
  correctly.

  v:register  |  the register in effect.
  v:char      |  character that was typed to trigger the abbreviation

  <expr> can be used in map or abbreviation
    :inoremap <expr> key expression  " evaluate expression as rhs
    :ab[breviate] [<expr>] [<buffer>] {lhs} {rhs}

git:
  If do something like :
    git checkout sha1
  You will be in 'detached head' state, git won't be able to handle you change
  in this state. You should always use
    git checkout -b newbranch sha1

gl:
  normal achieved from normal still needs to be normalized:
    // be very careful about this!!, not easay to debug, totally nightmare
    vec3 t_normal = normalize(texture(normal_map, fi.texcoord).xyz * 2 - 1); 

linux:
  there are two kinds of clipboard:
    CLIPBOARD SELECTION works as traditional clipboard.  according to + in vim
    PRMARY SELECTION works on last heightlight, pasted with middle mouse.
    according to * in vim.
    SECONDARY SELECTION was never used by me.
  You need some tool such xsel to connect tty and xwindow selection. :
    echo balabala  | xsel -i   # set primary selection to balabala
  If you are using neovim, you should install of of this kind of tool.

-----------
2018.02.01:

linux:
  swap works likes virtual memory on windows.

  device:
    a device file or special file is an interface for a device driver that
    appears in a file system as if it were an ordinary file. They allow software
    to interact with a device driver using standard input/output system calls,
    which simplifies many tasks and unifies user-space I/O mechanisms.

  There are two general kinds of device files in Unix-like operating systems:
    character devices(not used in linux):
      provide unbuffered, direct access to the hardware device.

    block device:
      provide buffered access to hardware devices, and provide some abstraction
      from their specifics. Unlike character devices, block devices will always
      allow the programmer to read or write a block of any size (including
      single characters/bytes) and any alignment. 

  Pseudo-devices: 
    Device nodes on Unix-like systems do not necessarily have to correspond to
    physical devices. Nodes that lack this correspondence form the group of
    pseudo-devices.

  Some of the most commonly used (character-based) pseudo-devices include:
    /dev/null – accepts and discards all input; produces no output (always
                returns an end-of-file indication on a read)
    /dev/zero – accepts and discards all input; produces a continuous stream of
                NUL (zero value) bytes
    /dev/full – produces a continuous stream of NUL (zero value) bytes when
                read, and returns a "disk full" message when written to
    /dev/random and /dev/urandom – they produce a variable-length stream of
                                   pseudo-random numbers.

  In Unix-like operating systems, a loop device, vnd (vnode disk), or lofi (loop
  file interface) is a pseudo-device that makes a file accessible as a block
  device. such as:
    mount -o loop /media/balabala /dsfsdf/sdf.iso

  linux style file system:
    inode:
      inode is a data structure in a Unix-style file system that describes a
      filesystem object such as a file or a directory. Each inode stores the
      attributes and disk block location(s) of the object's data.Filesystem object
      attributes may include metadata (times of last change, access,
      modification), as well as owner and permission data.
      Every file has one inode.

    block:
      real file content, a file may take multiple blocks.

    directory:
      directy block stores child inode and their name(just like hard link),
      which means if you want to add/delete/rename a file in a directory, you
      need w privilege.

    link:
      hard link:
        simply add a new inode name pair in directory data block, no new inode
        created. You can only create hard link in the same filesystem. You can
        not create hard link for directory. 
      symbolic link:
        Add a new file, it's datablock is the target. It's a new file, it has
        it's own inode an datablock.

    number of hard links:
      a file has 1 hard link when it's created, it's stored in it's parent
      directory, it increases every time you create a hardlink for it. 

      a directory has 2 had link when it's created, one in it's parent
      directory, one in special entry '.', whose inode is the directory it self.
      it also increases everytime you create a child directory in it, as special
      entry '..' of child directory will point to it's parent, 
